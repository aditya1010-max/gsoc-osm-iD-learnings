1️⃣ Each PR has a single clear purpose

Example progression:

PR 1:

Add kbar folder + empty scaffold (no behavior)

PR 2:

Add action registry (no UI yet)

PR 3:

Render static command list

PR 4:

Keyboard open/close logic

PR 5:

Filtering + search

Each PR:

compiles

passes CI

can be reviewed in isolation


WHY STEP BY STEP PRS?


1️⃣ You learn why files exist, not just what’s inside them

If you start with:

registry.js
palette.js
render.js
events.js


and add them one by one, you naturally ask:

Why is this logic not in index.js?

What should this file own?

What should it never know about?

That’s architectural thinking — and you cannot get it by pasting working code


2️⃣ You develop “interface thinking” (this is huge)

Early PRs force you to write things like:

export function kbarRegistry(context) {
  return [];
}


Even though it does nothing.

This teaches you:

how modules talk to each other

what data shape should look like

what future code will depend on

This is exactly how large systems are designed.


3️⃣ You’ll finally understand iD’s codebase deeply

iD is not a tutorial project. It’s:

D3-heavy

event-driven

side-effect-aware

historically layered

By building kbar incrementally, you’ll learn:

how UI modules are wired

how context flows

how actions trigger modes

where not to put logic

That knowledge transfers to any large JS codebase.