1ï¸âƒ£ Types of tests (quick taxonomy)

In a frontend codebase like iD, you generally see:

Unit tests

Integration tests

End-to-end (E2E) tests

For Kbar, you will mostly write unit tests, and maybe one light integration-style test.

2ï¸âƒ£ What you should write for Kbar (realistically)
âœ… MUST-HAVE: Unit tests

These are small, fast, and live under test/unit/.

They test:

one function

with fake inputs

no real DOM

no real map

This is where 90% of your testing effort goes.

âš ï¸ OPTIONAL: Light integration tests

These test:

2â€“3 modules working together

still no real browser

still no real map rendering

Nice to have, not mandatory for your PR.

âŒ NOT needed for Kbar (right now)

Full E2E browser tests

Visual snapshot tests

Performance tests

Maintainers will not expect these for a first Kbar PR.

3ï¸âƒ£ File-by-file: what tests to write

Now the important part ğŸ‘‡
Letâ€™s map each Kbar file â†’ test types â†’ what to assert.

filter.js â†’ PURE UNIT TESTS (very important)

This is the most test-worthy file.

Why?

Pure function

No side effects

Your bug lives here conceptually

Tests you should write

âœ… Behavior tests

empty query returns all actions

single-word query filters correctly

multi-word query matches in any order

non-matching query returns empty array

âœ… Safety tests

does not mutate input array

handles extra spaces (" add point ")

ğŸ’¡ This is where you lock in the bug fix permanently.

registry.js â†’ CONTRACT tests

Registry is not logic-heavy, so donâ€™t over-test it.

What to test

âœ… Every action has:

id (string)

title (string)

onSelect (function)

âœ… Calling the registry twice returns:

a new array

not the same reference

Example intent:

â€œRegistry always gives me a fresh, well-formed action list.â€

Thatâ€™s it. One or two tests max.

lifecycle.js â†’ BEHAVIORAL unit test

Small but important.

What to test

âœ… When close(reason) is called:

overlay is hidden

focus is restored

onClose(reason) is invoked

You do not test:

CSS

animation

actual DOM focus behavior

Just the contract.

events.js (or input handler) â†’ STATE FLOW tests

This is where your bug actually lived.

What to test (if you touch this file)

âœ… Filtering always uses:

full action list

not the already-filtered list

âœ… Typing flow:

"p" â†’ "po" â†’ "point" â†’ "add point" works

This may be:

a unit test with mocked dependencies

or a light integration test

If the file is complex and you didnâ€™t change much, you can justify not adding tests here and rely on filter.js tests.

render.js â†’ Usually no unit tests

Rendering code tends to be:

DOM-heavy

brittle to test

not where logic bugs live

Unless you changed rendering logic:

skip tests here

Maintainers are fine with this.

orchestrator.js â†’ OPTIONAL integration-style test

If this file:

wires everything together

owns state like allActions

calls filterActions

Then one test can be valuable:

â€œFiltering is always based on the full registry result.â€

But again: optional unless you touched it heavily.

4ï¸âƒ£ What you do NOT need to test

This is important so you donâ€™t overwork yourself.

You do NOT need to test:

exact titles ("Add Point" text)

localization keys

icons

exact ordering of actions

internal helper functions that are trivial

Test behavior, not implementation.

5ï¸âƒ£ Minimal but strong test plan for your PR

If I were reviewing your PR, Iâ€™d be very happy with:

âœ… filterActions tests (4â€“6 cases)

âœ… lifecycle.js close behavior test

âœ… registry.js shape test (1 test)

Thatâ€™s it.

Anything beyond that is a bonus.

6ï¸âƒ£ One golden rule to remember

Test the contracts you rely on, not every line of code.

Your contracts are:

filtering is order-independent

source actions are never mutated

closing always restores focus